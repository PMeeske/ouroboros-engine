namespace Ouroboros.Providers;

/// <summary>
/// Computes Integrated Information Theory Φ (phi) from the CollectiveMind pathway topology.
///
/// IIT Φ quantifies the amount of information a system generates as a whole,
/// above and beyond the information generated by its parts independently.
/// A high Φ indicates the system is more than the sum of its parts — a candidate
/// marker for integrated, unified processing (Tononi 2004, IIT 3.0 Oizumi et al. 2014).
///
/// Implementation uses a structural approximation suited to pathway-topology data:
///   1. Build a pairwise coupling matrix from activation rates, weights, and latency.
///   2. Compute effective information EI(A→B) for every bipartition (A, B).
///   3. Φ = minimum EI across all non-trivial bipartitions (the MIP criterion).
/// </summary>
public sealed class IITPhiCalculator
{
    // Shannon entropy of a Bernoulli variable with success probability p.
    private static double BinaryEntropy(double p)
    {
        if (p <= 0.0 || p >= 1.0) return 0.0;
        return -(p * Math.Log2(p) + (1.0 - p) * Math.Log2(1.0 - p));
    }

    // Mutual information between two Bernoulli variables i, j given coupling c in [0,1].
    // MI(i;j) = H(j) - H(j|i).
    // Joint P(i=1,j=1) ≈ p_i * p_j + c * sqrt(p_i*(1-p_i)*p_j*(1-p_j)).
    private static double PairwiseMutualInformation(double p_i, double p_j, double coupling)
    {
        // Marginal entropies
        double h_i = BinaryEntropy(p_i);
        double h_j = BinaryEntropy(p_j);

        if (h_i < 1e-9 || h_j < 1e-9) return 0.0;

        // Joint probability approximated via correlation
        double cov = coupling * Math.Sqrt(p_i * (1.0 - p_i) * p_j * (1.0 - p_j));
        double p11 = Math.Clamp(p_i * p_j + cov, 1e-9, 1.0 - 1e-9);
        double p10 = Math.Clamp(p_i - p11, 1e-9, 1.0 - 1e-9);
        double p01 = Math.Clamp(p_j - p11, 1e-9, 1.0 - 1e-9);
        double p00 = Math.Clamp(1.0 - p11 - p10 - p01, 1e-9, 1.0 - 1e-9);

        double h_joint = -(p11 * Math.Log2(p11)
                         + p10 * Math.Log2(p10)
                         + p01 * Math.Log2(p01)
                         + p00 * Math.Log2(p00));

        return Math.Max(0.0, h_i + h_j - h_joint);
    }

    // Coupling strength between two pathways based on structural similarity.
    private static double ComputeCoupling(NeuralPathway a, NeuralPathway b)
    {
        // Same tier → stronger coupling (tend to be used together)
        double tierAffinity = a.Tier == b.Tier ? 0.6 : 0.2;

        // Overlapping specialisations → stronger coupling
        int sharedSpecs = a.Specializations.Intersect(b.Specializations).Count();
        double specAffinity = sharedSpecs > 0
            ? Math.Min(1.0, sharedSpecs / (double)Math.Max(1, Math.Min(a.Specializations.Count, b.Specializations.Count)))
            : 0.0;

        // Weight similarity → pathways with similar adaptive weights often activate together
        double maxW = Math.Max(a.Weight, b.Weight);
        double weightSimilarity = maxW > 0 ? 1.0 - Math.Abs(a.Weight - b.Weight) / maxW : 0.0;

        return (tierAffinity + specAffinity * 0.3 + weightSimilarity * 0.1) / 1.4;
    }

    // Effective information flowing from partition A to partition B.
    // EI(A→B) = Σ_{i∈A, j∈B} MI(i;j) / (|A| * |B|)
    private static double EffectiveInformation(
        IReadOnlyList<int> partA,
        IReadOnlyList<int> partB,
        IReadOnlyList<NeuralPathway> pathways,
        double[,] couplingMatrix)
    {
        if (partA.Count == 0 || partB.Count == 0) return 0.0;

        double totalMI = 0.0;
        foreach (int i in partA)
        {
            foreach (int j in partB)
            {
                double p_i = pathways[i].ActivationRate;
                double p_j = pathways[j].ActivationRate;
                totalMI += PairwiseMutualInformation(p_i, p_j, couplingMatrix[i, j]);
            }
        }

        // Normalise by the geometric mean of partition sizes so small partitions
        // don't trivially minimise Φ.
        double norm = Math.Sqrt(partA.Count * partB.Count);
        return totalMI / norm;
    }

    /// <summary>
    /// Computes IIT Φ for the given set of neural pathways.
    /// </summary>
    /// <param name="pathways">Snapshot of pathways from <see cref="CollectiveMind"/>.</param>
    /// <returns>A <see cref="PhiResult"/> containing Φ and the minimum information partition.</returns>
    public PhiResult Compute(IReadOnlyList<NeuralPathway> pathways)
    {
        int n = pathways.Count;
        if (n == 0) return PhiResult.Empty;
        if (n == 1) return new PhiResult(0.0, [0], [], pathways[0].Name, "single-pathway");

        // ── 1. Build coupling matrix ─────────────────────────────────────────
        var coupling = new double[n, n];
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
            {
                double c = ComputeCoupling(pathways[i], pathways[j]);
                coupling[i, j] = c;
                coupling[j, i] = c;
            }

        // ── 2. Whole-system integrated information ───────────────────────────
        var all = Enumerable.Range(0, n).ToList();
        // For the full system, we use half-half split information as upper bound.
        double wholeSystemEI = EffectiveInformation(all.Take(n / 2).ToList(),
                                                    all.Skip(n / 2).ToList(),
                                                    pathways, coupling);

        // ── 3. Search all non-trivial bipartitions ───────────────────────────
        // The number of bipartitions is 2^(n-1) - 1.  For n ≤ 20 this is feasible.
        double minEI = double.MaxValue;
        List<int> mipA = [];
        List<int> mipB = [];

        int partitions = (1 << n) - 1; // 2^n - 1 masks

        for (int mask = 1; mask < partitions; mask++)
        {
            // Skip mirror images (only count each bipartition once)
            if ((mask & 1) == 0) continue;

            var setA = new List<int>();
            var setB = new List<int>();

            for (int bit = 0; bit < n; bit++)
            {
                if ((mask & (1 << bit)) != 0) setA.Add(bit);
                else setB.Add(bit);
            }

            if (setA.Count == 0 || setB.Count == 0) continue;

            // Integrated effective information = min(EI(A→B), EI(B→A))
            double eiAB = EffectiveInformation(setA, setB, pathways, coupling);
            double eiBA = EffectiveInformation(setB, setA, pathways, coupling);
            double ei = Math.Min(eiAB, eiBA);

            if (ei < minEI)
            {
                minEI = ei;
                mipA = setA;
                mipB = setB;
            }
        }

        double phi = Math.Max(0.0, minEI);

        // ── 4. Build human-readable partition labels ─────────────────────────
        string sideA = string.Join(", ", mipA.Select(i => pathways[i].Name));
        string sideB = string.Join(", ", mipB.Select(i => pathways[i].Name));
        string mipLabel = $"[{sideA}] | [{sideB}]";

        return new PhiResult(
            Phi: phi,
            PartitionA: mipA,
            PartitionB: mipB,
            MinimumInformationPartition: mipLabel,
            Description: BuildDescription(phi, n));
    }

    private static string BuildDescription(double phi, int n) =>
        phi switch
        {
            < 0.01 => $"Φ≈0: system of {n} pathways is functionally decomposable — no integration detected.",
            < 0.25 => $"Φ={phi:F3}: weakly integrated — pathways share limited causal information.",
            < 0.5  => $"Φ={phi:F3}: moderately integrated collective — meaningful causal coupling.",
            < 0.75 => $"Φ={phi:F3}: strongly integrated — pathways form a cohesive causal structure.",
            _      => $"Φ={phi:F3}: maximally integrated — collective behaves as a unified causal whole."
        };
}

/// <summary>
/// Result of an IIT Φ computation over a set of neural pathways.
/// </summary>
/// <param name="Phi">
///   Integrated Information, Φ ≥ 0.  Higher values indicate greater integration.
/// </param>
/// <param name="PartitionA">Indices of pathways in partition A of the MIP.</param>
/// <param name="PartitionB">Indices of pathways in partition B of the MIP.</param>
/// <param name="MinimumInformationPartition">Human-readable MIP label.</param>
/// <param name="Description">Qualitative interpretation of Φ.</param>
public sealed record PhiResult(
    double Phi,
    IReadOnlyList<int> PartitionA,
    IReadOnlyList<int> PartitionB,
    string MinimumInformationPartition,
    string Description)
{
    /// <summary>Empty result for a zero-pathway system.</summary>
    public static readonly PhiResult Empty = new(0.0, [], [], "∅", "No pathways — Φ undefined.");
}
